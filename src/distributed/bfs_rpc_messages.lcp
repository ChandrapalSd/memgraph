#>cpp
#pragma once

#include <tuple>

#include "communication/rpc/messages.hpp"
#include "distributed/bfs_subcursor.hpp"
#include "query/frontend/semantic/symbol_table.hpp"
#include "query/distributed/plan/ops.hpp"
#include "query/distributed/serialization.hpp"
#include "storage/distributed/rpc/serialization.hpp"
#include "transactions/type.hpp"
cpp<#

(lcp:namespace distributed)

(lcp:define-rpc create-bfs-subcursor
    (:request
     ((tx-id "::tx::TransactionId")
      (direction "::query::EdgeAtom::Direction")
      (edge-types "std::vector<storage::EdgeType>")
      (filter-lambda "::query::plan::ExpansionLambda"
                     :slk-load (lambda (member)
                                 #>cpp
                                 slk::Load(&self->${member}, reader, ast_storage);
                                 cpp<#))
      (symbol-table "::query::SymbolTable")
      (timestamp :int64_t)
      (parameters "::query::Parameters"))
     (:serialize (:slk :load-args '((ast-storage "::query::AstStorage *")))))
  (:response ((member :int64_t))))

(lcp:define-rpc register-subcursors
    (:request ((subcursor-ids "std::unordered_map<int16_t, int64_t>")))
  (:response ()))

(lcp:define-rpc reset-subcursor
    (:request ((subcursor-id :int64_t)))
    (:response ()))

(lcp:define-enum expand-result
  (success failure lambda-error)
  (:serialize))

(lcp:define-rpc expand-level
    (:request ((member :int64_t)))
  (:response ((result "ExpandResult"))))

(lcp:define-rpc subcursor-pull
  (:request ((member :int64_t)))
  (:response
    ((vertex "std::optional<VertexAccessor>"
             :slk-save (lambda (member)
                         #>cpp
                         slk::Save(static_cast<bool>(self.${member}), builder);
                         if (self.${member}) {
                           slk::Save(*self.${member}, builder,
                                     storage::SendVersions::BOTH, worker_id);
                         }
                         cpp<#)
             :slk-load (lambda (member)
                         #>cpp
                         bool has_value;
                         slk::Load(&has_value, reader);
                         if (has_value) {
                           self->${member} = slk::LoadVertexAccessor(reader, dba, data_manager);
                         }
                         cpp<#)))
   (:serialize (:slk :save-args '((worker-id :int16_t))
                     :load-args '((dba "::database::GraphDbAccessor *")
                                  (data-manager "::distributed::DataManager *"))))))

(lcp:define-rpc set-source
    (:request
     ((subcursor-id :int64_t)
      (source "::storage::VertexAddress")))
  (:response ()))

(lcp:define-rpc expand-to-remote-vertex
    (:request
     ((subcursor-id :int64_t)
      (edge "::storage::EdgeAddress")
      (vertex "::storage::VertexAddress")))
  (:response ((member :bool))))

(lcp:define-rpc reconstruct-path
    (:request
     ((subcursor-id :int64_t)
      (vertex "std::optional<storage::VertexAddress>")
      (edge "std::optional<storage::EdgeAddress>"))
     (:public
      #>cpp
      ReconstructPathReq() {}

      ReconstructPathReq(int64_t subcursor_id, storage::VertexAddress vertex)
          : subcursor_id(subcursor_id),
            vertex(vertex),
            edge(std::nullopt) {}

      ReconstructPathReq(int64_t subcursor_id, storage::EdgeAddress edge)
          : subcursor_id(subcursor_id),
            vertex(std::nullopt),
            edge(edge) {}
      cpp<#))
  (:response
   ((edges "std::vector<EdgeAccessor>"
           :slk-save (lambda (member)
                       #>cpp
                       size_t size = self.${member}.size();
                       slk::Save(size, builder);
                       for (const auto &v : self.${member}) {
                         slk::Save(v, builder, storage::SendVersions::BOTH, worker_id);
                       }
                       cpp<#)
           :slk-load (lambda (member)
                       #>cpp
                       size_t size;
                       slk::Load(&size, reader);
                       self->${member}.reserve(size);
                       for (size_t i = 0; i < size; ++i) {
                         self->${member}.push_back(slk::LoadEdgeAccessor(reader, dba, data_manager));
                       }
                       cpp<#))
    (next-vertex "std::optional<storage::VertexAddress>")
    (next-edge "std::optional<storage::EdgeAddress>"))
   (:serialize (:slk :save-args '((worker-id :int16_t))
                     :load-args '((dba "database::GraphDbAccessor *")
                                  (data-manager "distributed::DataManager *"))))
   (:public
    #>cpp
    ReconstructPathRes() {}

    ReconstructPathRes(
        const std::vector<EdgeAccessor> &edges,
        std::optional<storage::VertexAddress> next_vertex,
        std::optional<storage::EdgeAddress> next_edge)
        : edges(edges), next_vertex(std::move(next_vertex)), next_edge(std::move(next_edge)) {
      CHECK(!static_cast<bool>(next_vertex) || !static_cast<bool>(next_edge))
          << "At most one of `next_vertex` and `next_edge` should be set";
    }
    cpp<#)))

(lcp:define-rpc prepare-for-expand
    (:request
     ((subcursor-id :int64_t)
      (clear :bool)
      (frame "std::vector<query::TypedValue>"
             :slk-save (lambda (member)
                         #>cpp
                         size_t size = self.${member}.size();
                         slk::Save(size, builder);
                         for (const auto &v : self.${member}) {
                           slk::Save(v, builder, storage::SendVersions::ONLY_OLD, self.worker_id);
                         }
                         cpp<#)
             :slk-load (lambda (member)
                         #>cpp
                         auto *subcursor = subcursor_storage->Get(self->subcursor_id);
                         size_t size;
                         slk::Load(&size, reader);
                         self->${member}.resize(size);
                         for (size_t i = 0; i < size; ++i) {
                           slk::Load(&self->${member}[i], reader, subcursor->db_accessor(), data_manager);
                         }
                         cpp<#))
      (worker-id :int16_t :dont-save t))
     (:serialize (:slk :load-args '((subcursor_storage "distributed::BfsSubcursorStorage *")
                                    (data-manager "distributed::DataManager *")))))
  (:response ()))

(lcp:pop-namespace) ;; distributed
