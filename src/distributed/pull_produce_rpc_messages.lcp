#>cpp
#pragma once

#include <cstdint>
#include <functional>
#include <string>

#include "communication/rpc/messages.hpp"
#include "distributed/pull_produce_rpc_messages.capnp.h"
#include "distributed/serialization.hpp"
#include "query/frontend/semantic/symbol.hpp"
#include "query/parameters.hpp"
#include "storage/address_types.hpp"
#include "transactions/type.hpp"
#include "utils/serialization.hpp"
cpp<#

(lcp:in-impl
 #>cpp
 #include "database/distributed_graph_db.hpp"
 #include "database/graph_db_accessor.hpp"
 #include "distributed/data_manager.hpp"
 cpp<#)

(lcp:namespace distributed)

(lcp:capnp-namespace "distributed")

(lcp:capnp-import 'dis "/distributed/serialization.capnp")
(lcp:capnp-import 'sem "/query/frontend/semantic/symbol.capnp")
(lcp:capnp-import 'tx "/transactions/common.capnp")
(lcp:capnp-import 'utils "/utils/serialization.capnp")

(lcp:capnp-type-conversion "tx::CommandId" "UInt32")
(lcp:capnp-type-conversion "tx::Snapshot" "Tx.Snapshot")
(lcp:capnp-type-conversion "tx::TransactionId" "UInt64")

#>cpp
// Forward declare for LoadGraphElement.
class DataManager;

/// The default number of results returned via RPC from remote execution to the
/// master that requested it.
constexpr int kDefaultBatchSize = 20;
cpp<#

(lcp:define-enum pull-state
    (cursor-exhausted
     cursor-in-progress
     serialization-error
     lock-timeout-error
     update-deleted-error
     reconstruction-error
     unable-to-delete-vertex-error
     hinted-abort-error
     query-error)
  (:documentation "Returned along with a batch of results in the remote-pull
RPC. Indicates the state of execution on the worker.")
  (:serialize))

(lcp:define-struct pull-data ()
  ((pull-state "PullState")
   (frames "std::vector<std::vector<query::TypedValue>>"))
  (:documentation
   "The data returned to the end consumer (the Pull operator). Contains only
the relevant parts of the response, ready for use."))

(lcp:define-struct pull-res-data ()
  ((pull-state "PullState")
   (frames "std::vector<std::vector<query::TypedValue>>"
           :capnp-type "List(List(Dis.TypedValue))"
           :capnp-save
           (lambda (builder member)
             #>cpp
             for (size_t frame_i = 0; frame_i < ${member}.size(); ++frame_i) {
               const auto &frame = ${member}[frame_i];
               auto frame_builder = ${builder}.init(frame_i, frame.size());
               for (size_t val_i = 0; val_i < frame.size(); ++val_i) {
                 const auto &value = frame[val_i];
                 auto value_builder = frame_builder[val_i];
                 utils::SaveCapnpTypedValue(
                     value, &value_builder,
                     [this](const auto &value, auto *builder) {
                       this->SaveGraphElement(value, builder);
                     });
               }
             }
             cpp<#)
           :capnp-load
           (lambda (reader member)
             #>cpp
             ${member}.reserve(${reader}.size());
             for (const auto &frame_reader : ${reader}) {
               std::vector<query::TypedValue> current_frame;
               current_frame.reserve(frame_reader.size());
               for (const auto &value_reader : frame_reader) {
                 query::TypedValue value;
                 utils::LoadCapnpTypedValue(
                     value_reader, &value,
                     [this, dba, data_manager](const auto &reader, auto *value) {
                       this->LoadGraphElement(dba, reader, value, data_manager);
                     });
                 current_frame.emplace_back(value);
               }
               ${member}.emplace_back(current_frame);
             }
             cpp<#))
   (worker-id :int16_t :capnp-save :dont-save
              :documentation
              "Id of the worker on which the response is created, used for
serializing vertices (converting local to global addresses). Indicates which
of (old, new) records of a graph element should be sent.")
   (send-old :bool :capnp-save :dont-save)
   (send-new :bool :capnp-save :dont-save)
   ;; Temporary caches used between deserialization and post-processing
   ;; (transfering the ownership of this data to a Cache).
   (vertices "std::vector<GraphElementData<Vertex>>" :capnp-save :dont-save)
   (edges "std::vector<GraphElementData<Edge>>" :capnp-save :dont-save)
   (paths "std::vector<PathData>" :capnp-save :dont-save))
  (:documentation
   "The data of the remote pull response. Post-processing is required after
deserialization to initialize Vertex/Edge typed values in the frames (possibly
encapsulated in lists/maps) to their proper values. This requires a
GraphDbAccessor and therefore can't be done as part of deserialization.

TODO - make it possible to inject a &GraphDbAcessor from the Pull layer all
the way into RPC data deserialization to remove the requirement for
post-processing. The current approach of holding references to parts of the
frame (potentially embedded in lists/maps) is too error-prone.")
  (:public
   #>cpp
   private:
   cpp<#
   (lcp:define-struct (graph-element-data t-record) ()
     ((global-address "storage::Address<mvcc::VersionList<TRecord>>")
      (old-record "std::unique_ptr<TRecord>")
      (new-record "std::unique_ptr<TRecord>")
      (element-in-frame
       "query::TypedValue *"
       :documentation
       "The position in frame is optional. This same structure is used for
deserializing path elements, in which case the vertex/edge in question is not
directly part of the frame."))
     (:documentation
      "Temp cache for deserialized vertices and edges. These objects are
created during deserialization. They are used immediatelly after during
post-processing. The vertex/edge data ownership gets transfered to the Cache,
and the `element_in_frame` reference is used to set the appropriate accessor
to the appropriate value. Not used on side that generates the response.")
     (:public
      #>cpp
      GraphElementData(storage::Address<mvcc::VersionList<TRecord>> address,
                       std::unique_ptr<TRecord> old_record, std::unique_ptr<TRecord> new_record,
                       query::TypedValue *element_in_frame)
        : global_address(address),
          old_record(std::move(old_record)),
          new_record(std::move(new_record)),
          element_in_frame(element_in_frame) {}
      cpp<#))
   (lcp:define-struct path-data ()
     ((vertices "std::vector<GraphElementData<Vertex>>")
      (edges "std::vector<GraphElementData<Edge>>")
      (path-in-frame "query::TypedValue *"))
     (:public
      #>cpp
      PathData(query::TypedValue *path_in_frame) : path_in_frame(path_in_frame) {}
      cpp<#)
     (:documentation "Same like `GraphElementData`, but for paths."))
   #>cpp
   public:
    PullResData() {}  // Default constructor required for serialization.
    PullResData(int worker_id, bool send_old, bool send_new)
        : worker_id(worker_id), send_old(send_old), send_new(send_new) {}

    PullResData(const PullResData &) = delete;
    PullResData &operator=(const PullResData &) = delete;
    PullResData(PullResData &&) = default;
    PullResData &operator=(PullResData &&) = default;
   cpp<#)
  (:private
   #>cpp
   void SaveGraphElement(const query::TypedValue &,
                         distributed::capnp::TypedValue::Builder *) const;
   void LoadGraphElement(database::GraphDbAccessor *,
                         const distributed::capnp::TypedValue::Reader &,
                         query::TypedValue *, distributed::DataManager *);
   cpp<#)
  (:serialize :capnp :load-args '((dba "database::GraphDbAccessor *")
                                  (data-manager "distributed::DataManager *"))))

(lcp:in-impl
 #>cpp
 void PullResData::SaveGraphElement(
     const query::TypedValue &value,
     distributed::capnp::TypedValue::Builder *builder) const {
   auto save_element = [this](auto accessor, auto *builder) {
     builder->setAddress(accessor.GlobalAddress().raw());
     // If both old and new are null, we need to reconstruct
     if (!(accessor.GetOld() || accessor.GetNew())) {
       bool result = accessor.Reconstruct();
       CHECK(result) << "Attempting to serialize an element not visible to "
                        "current transaction.";
     }
     auto *old_rec = accessor.GetOld();
     if (send_old && old_rec) {
       auto old_builder = builder->initOld();
       distributed::SaveElement(*old_rec, &old_builder, worker_id);
     }
     if (send_new) {
       // Must call SwitchNew as that will trigger a potentially necesary
       // Reconstruct.
       accessor.SwitchNew();
       auto *new_rec = accessor.GetNew();
       if (new_rec) {
         auto new_builder = builder->initNew();
         distributed::SaveElement(*new_rec, &new_builder, worker_id);
       }
     }
   };
   switch (value.type()) {
     case query::TypedValue::Type::Vertex: {
       auto vertex_builder = builder->initVertex();
       save_element(value.ValueVertex(), &vertex_builder);
       break;
     }
     case query::TypedValue::Type::Edge: {
       auto edge_builder = builder->initEdge();
       save_element(value.ValueEdge(), &edge_builder);
       break;
     }
     case query::TypedValue::Type::Path: {
       const auto &path = value.ValuePath();
       auto path_builder = builder->initPath();
       auto vertices_builder = path_builder.initVertices(path.vertices().size());
       for (size_t i = 0; i < path.vertices().size(); ++i) {
         auto vertex_builder = vertices_builder[i];
         save_element(path.vertices()[i], &vertex_builder);
       }
       auto edges_builder = path_builder.initEdges(path.edges().size());
       for (size_t i = 0; i < path.edges().size(); ++i) {
         auto edge_builder = edges_builder[i];
         save_element(path.edges()[i], &edge_builder);
       }
       break;
     }
     default:
       LOG(FATAL) << "Unsupported graph element type: " << value.type();
   }
 }

void PullResData::LoadGraphElement(
    database::GraphDbAccessor *dba,
    const distributed::capnp::TypedValue::Reader &reader,
    query::TypedValue *value, distributed::DataManager *data_manager) {
  auto load_vertex = [dba, data_manager](const auto &vertex_reader) {
    storage::VertexAddress global_address(vertex_reader.getAddress());
    auto old_record =
        vertex_reader.hasOld()
            ? distributed::LoadVertex(vertex_reader.getOld())
            : nullptr;
    auto new_record =
        vertex_reader.hasNew()
            ? distributed::LoadVertex(vertex_reader.getNew())
            : nullptr;
    data_manager->Emplace<Vertex>(dba->transaction_id(), global_address.gid(), 
                 std::move(old_record), std::move(new_record));
    return VertexAccessor(global_address, *dba);
  };
  auto load_edge = [dba, data_manager](const auto &edge_reader) {
    storage::EdgeAddress global_address(edge_reader.getAddress());
    auto old_record =
        edge_reader.hasOld()
            ? distributed::LoadEdge(edge_reader.getOld())
            : nullptr;
    auto new_record =
        edge_reader.hasNew()
            ? distributed::LoadEdge(edge_reader.getNew())
            : nullptr;
    data_manager->Emplace<Edge>(dba->transaction_id(), global_address.gid(),
                 std::move(old_record), std::move(new_record));
    return EdgeAccessor(global_address, *dba);
  };
  switch (reader.which()) {
    case distributed::capnp::TypedValue::VERTEX:
      *value = load_vertex(reader.getVertex());
      break;
    case distributed::capnp::TypedValue::EDGE:
      *value = load_edge(reader.getEdge());
      break;
    case distributed::capnp::TypedValue::PATH: {
      auto vertices_reader = reader.getPath().getVertices();
      auto edges_reader = reader.getPath().getEdges();
      query::Path path(load_vertex(vertices_reader[0]));
      for (size_t i = 0; i < edges_reader.size(); ++i) {
        path.Expand(load_edge(edges_reader[i]));
        path.Expand(load_vertex(vertices_reader[i + 1]));
      }
      *value = path;
      break;
    }
    default:
      LOG(FATAL) << "Unsupported graph element type.";
  }
}

cpp<#)

(lcp:define-rpc pull
    (:request
     ((tx-id "tx::TransactionId")
      (tx-snapshot "tx::Snapshot")
      (plan-id :int64_t)
      (command-id "tx::CommandId")
      (params "Parameters"
              :capnp-type "Utils.Map(Utils.BoxInt64, Dis.TypedValue)"
              :capnp-save
              (lambda (builder member)
                #>cpp
                auto entries_builder = ${builder}.initEntries(${member}.size());
                size_t i = 0;
                for (auto &entry : params) {
                  auto builder = entries_builder[i];
                  auto key_builder = builder.initKey();
                  key_builder.setValue(entry.first);
                  auto value_builder = builder.initValue();
                  utils::SaveCapnpTypedValue(entry.second, &value_builder);
                  ++i;
                }
                cpp<#)
              :capnp-load
              (lambda (reader member)
                #>cpp
                for (const auto &entry_reader : ${reader}.getEntries()) {
                  query::TypedValue value;
                  utils::LoadCapnpTypedValue(entry_reader.getValue(), &value);
                  ${member}.Add(entry_reader.getKey().getValue(), value);
                }
                cpp<#))
      (symbols "std::vector<query::Symbol>" :capnp-type "List(Sem.Symbol)")
      (timestamp :int64_t)
      (accumulate :bool)
      (batch-size :int64_t)
      ;; Indicates which of (old, new) records of a graph element should be sent.
      (send-old :bool)
      (send-new :bool)))
  (:response
   ((data "PullResData" :initarg :move))
   (:serialize :capnp :base t :load-args '((dba "database::GraphDbAccessor *")
                                           (data-manager "distributed::DataManager *")))))

;; TODO make a separate RPC for the continuation of an existing pull, as an
;; optimization not to have to send the full PullReqData pack every time.

(lcp:define-rpc reset-cursor
    (:request
     ((tx-id "tx::TransactionId")
      (plan-id :int64_t)
      (command-id "tx::CommandId")))
    (:response ()))

(lcp:define-rpc transaction-command-advanced
    (:request ((member "tx::TransactionId")))
  (:response ()))

(lcp:pop-namespace) ;; distributed
