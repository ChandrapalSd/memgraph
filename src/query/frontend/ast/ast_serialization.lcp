#>cpp
#pragma once

#include "query/frontend/ast/ast.hpp"
#include "query/frontend/ast/ast_serialization.capnp.h"
#include "query/serialization.hpp"
#include "storage/distributed/serialization.hpp"
cpp<#

(load "query/frontend/ast/ast.lcp")

(lcp:namespace query)

#>cpp
Tree *Load(AstStorage *ast, const capnp::Tree::Reader &tree,
           std::vector<int> *loaded_uids);
cpp<#

(lcp:in-impl
  #>cpp
  Tree *Load(AstStorage *ast, const capnp::Tree::Reader &tree,
             std::vector<int> *loaded_uids) {
    // Check if element already deserialized and if yes, return existing
    // element from storage.
    auto uid = tree.getUid();
    if (utils::Contains(*loaded_uids, uid)) {
      auto found = std::find_if(ast->storage_.begin(), ast->storage_.end(),
                                [&](const auto &n) { return n->uid_ == uid; });
      CHECK(found != ast->storage_.end());
      return found->get();
    }
    std::unique_ptr<Tree> root;
    ::query::Load(&root, tree, ast, loaded_uids);
    ast->storage_.emplace_back(std::move(root));
    loaded_uids->emplace_back(uid);
    ast->max_existing_uid_ = std::max(ast->max_existing_uid_, uid);
    return ast->storage_.back().get();
  }
  cpp<#)

(lcp:pop-namespace) ;; namespace query
