// TODO: include this into CMakeLists

// compile the shared library
// clang++ -std=c++1y mysql.cpp -o ../tmp/mysql.so -shared -fPIC
// clang++ -std=c++1y memsql.cpp -o ../tmp/memsql.so -shared -fPIC
// clang++ -std=c++1y dynamic_lib.cpp -o test.out -ldl

#include <iostream>
#include <fstream>
#include <vector>
#include <iterator>
#include <cstdlib>

#include "dc/dynamic_lib.hpp"
#include "utils/string/file.hpp"

class db
{
public:
    // If virtual methods don't have = 0 the compiler
    // won't create appropriate _ZTI symbol inside
    // the .so lib. That will lead to undefined symbol
    // error while the library is loading.
    //
    // TODO: why?
    virtual void name() const = 0;
    virtual void type() const = 0;
    virtual ~db() {}
};

typedef db* (*produce_t)();
typedef void (*destruct_t)(db*);

using std::cout;
using std::endl;

// dependent on specific dynamic code
// "configuration" of DynamicLib
// DynamicLib<MemgraphDynamicLib>
class MemgraphDynamicLib
{
public:
    const static std::string produce_name;
    const static std::string destruct_name;
    using produce = produce_t;
    using destruct = destruct_t;
};
const std::string MemgraphDynamicLib::produce_name = "produce";
const std::string MemgraphDynamicLib::destruct_name = "destruct";

int main()
{
    // -- compile example
    // string tmp_file_path = "tmp/tmp.cpp";
    // string tmp_so_path = "tmp/tmp.so";
    // string for_compile = "#include <iostream>\nint main() { std::cout << \"test\" << std::endl; return 0; }";

    // write(tmp_file_path, for_compile);
    // string test_command = prints("clang++", tmp_file_path, "-o", "test.out");
    // system(test_command.c_str());
    // -- end compile example

    // -- load example
    using db_lib = DynamicLib<MemgraphDynamicLib>;

    db_lib mysql_db("./tmp/mysql.so");
    mysql_db.load();
    auto mysql = mysql_db.produce_method();
    if (mysql) {
        mysql->name();
    }
    mysql_db.destruct_method(mysql);

    db_lib memsql_db("./tmp/memsql.so");
    memsql_db.load();
    auto memsql = memsql_db.produce_method();
    if (memsql) {
        memsql->name();
    }
    memsql_db.destruct_method(memsql);

    return 0;
}
